# 迭代器模式

在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。

既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：

a） 暴露了聚合类的内部表示，使其数据不安全；

b） 增加了客户的负担。

 

“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。

 

## 1 模式的定义与特点

迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

迭代器模式是一种对象行为型模式，其主要优点如下：

a） 访问一个聚合对象的内容而无须暴露它的内部表示。

b） 遍历任务交由迭代器完成，这简化了聚合类。

c） 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。

d） 增加新的聚合类和迭代器类都很方便，无须修改原有代码。

e） 封装性良好，为遍历不同的聚合结构提供一个统一的接口。

 

其主要缺点是：

增加了类的个数，这在一定程度上增加了系统的复杂性。

 

## 2 模式的结构与实现

迭代器模式结构中包含聚合和迭代器两个层次的结构。为方便扩展，迭代器模式常常和工厂方法模式结合。迭代器模式的UML图如下。有图可知，迭代器模式有以下几个角色：

- Iterator（抽象迭代器）：声明了访问和遍历聚合对象元素的接口，如first()方法用于访问聚合对象中第一个元素，next()方法用于访问下一个元素，hasNext()判断是否还有下一个元素，currentItem()方法用于获取当前元素。
- ConcreteIterator（具体迭代器）：实现抽象迭代器声明的方法，通常具体迭代器中会专门用一个变量（称为游标）来记录迭代器在聚合对象中所处的位置。
- Aggregate（抽象聚合类）：用于存储和管理元素对象，声明一个创建迭代器的接口，其实是一个抽象迭代器工厂的角色。
- ConcreteAggregate（具体聚合类）：实现了方法createIterator()，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator的实例。

![img](https://img-blog.csdnimg.cn/2019110310444590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxMTA3NDMz,size_16,color_FFFFFF,t_70)



## 3 迭代器模式代码实例

电视机遥控器是迭代器的一个现实应用，通过它可以实现对电视频道集合的遍历操作，电视机可以看成一个存储频道的聚合对象。本例将采用迭代器模式来模拟遥控器操作电视频道的过程。很明显，遥控器是一个具体的迭代器，具有上一个频道previous() 、下一个频道next()、当前频道currentChannel()等功能；需要遍历的聚合对象是电视频道的集合，即电视机。本例的UML图如下：

![img](https://img-blog.csdnimg.cn/20191103141040241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzIxMTA3NDMz,size_16,color_FFFFFF,t_70)